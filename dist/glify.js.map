{"version":3,"sources":["utils.ts","leaflet-bindings.ts","canvasoverlay.ts","map-matrix.ts","base.ts","points.ts","shapes.ts","line-feature-vertices.ts","lines.ts","color.ts","index.ts"],"names":[],"mappings":"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","file":"glify.js","sourceRoot":"../src","sourcesContent":["export function defaults(userSettings, defaults) {\n  const settings = {};\n\n  for (const i in defaults) {\n    if (!defaults.hasOwnProperty(i)) continue;\n    settings[i] = (userSettings.hasOwnProperty(i) ? userSettings[i] : defaults[i]);\n  }\n\n  return settings;\n}\n\n// -- converts latlon to pixels at zoom level 0 (for 256x256 tile size) , inverts y coord )\n// -- source : http://build-failed.blogspot.cz/2013/02/displaying-webgl-data-on-google-maps.html\nexport function latLonToPixel(latitude, longitude) {\n  const pi180 = Math.PI / 180.0,\n    pi4 = Math.PI * 4,\n    sinLatitude = Math.sin(latitude * pi180),\n    pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (pi4)) * 256,\n    pixelX = ((longitude + 180) / 360) * 256;\n\n  return {x: pixelX, y: pixelY};\n}\n\nexport function pointInCircle(centerPoint, checkPoint, radius) {\n  const distanceSquared = (centerPoint.x - checkPoint.x) * (centerPoint.x - checkPoint.x) + (centerPoint.y - checkPoint.y) * (centerPoint.y - checkPoint.y);\n  return distanceSquared <= radius * radius;\n}","import {\n  latLng as _latLng,\n  LatLng as _LatLng,\n  Layer as _Layer,\n} from 'leaflet/src/layer/Layer';\nimport {\n  Point as _Point,\n} from 'leaflet/src/geometry/Point';\nimport {\n  Browser as _Browser,\n  setOptions as _setOptions,\n  requestAnimFrame as _requestAnimFrame\n} from 'leaflet/src/core/Util';\nimport * as _DomUtil from 'leaflet/src/dom/DomUtil';\n\nexport const latLng: _LatLng = window['L'] ? window['L'].latLng : _latLng;\n\nexport const LatLng: _LatLng = window['L'] ? window['L'].LatLng : _LatLng;\n\nexport const Layer: _Layer = window['L'] ? window['L'].Layer : _Layer;\n\nexport const Point: _Point = window['L'] ? window['L'].Point : _Point;\n\nexport const setOptions: _setOptions = window['L'] ? window['L'].Util.setOptions : _setOptions;\n\nexport const Browser: _Browser = window['L'] ? window['L'].Browser : _Browser;\n\nexport const DomUtil: _DomUtil = window['L'] ? window['L'].DomUtil : _DomUtil;\n\nconst requestAnimFrame: _requestAnimFrame = window['L'] ? window['L'].Util.requestAnimFrame : _requestAnimFrame;\nexport const Util = {\n  requestAnimFrame\n};\n","/*\noriginally taken from: http://www.sumbera.com/gist/js/leaflet/canvas/L.CanvasOverlay.js, added and customized as part of this lib because of need from library\n Generic  Canvas Overlay for leaflet,\n Stanislav Sumbera, April , 2014\n\n - added userDrawFunc that is called when Canvas need to be redrawn\n - added few useful params fro userDrawFunc callback\n - fixed resize map bug\n inspired & portions taken from  :   https://github.com/Leaflet/Leaflet.heat\n */\nimport { LatLngBounds, Map, Point as PointReference } from 'leaflet';\nimport { Layer, Point, setOptions, Browser, DomUtil, Util } from './leaflet-bindings';\n\ninterface IUserDrawFuncContext {\n  canvas   : HTMLCanvasElement;\n  bounds   : LatLngBounds;\n  size     : PointReference;\n  zoomScale: number;\n  zoom     : number;\n  options  : any;\n}\n\nexport class CanvasOverlay extends Layer {\n  _userDrawFunc: (overlayInstance: CanvasOverlay, context: IUserDrawFuncContext) => void;\n  _map: Map;\n  _frame?: AnimationFrameProvider;\n  _redrawCallbacks: Function[];\n  canvas: HTMLCanvasElement;\n  options: any;\n\n  constructor(userDrawFunc: (overlayInstance: CanvasOverlay, context: IUserDrawFuncContext) => void, options = {}) {\n    super();\n    this._userDrawFunc = userDrawFunc;\n    this._frame = null;\n    this._redrawCallbacks = [];\n    this.options = options;\n    setOptions(this, options);\n  }\n\n  drawing(userDrawFunc) {\n    this._userDrawFunc = userDrawFunc;\n    return this;\n  }\n\n  params(options){\n    setOptions(this, options);\n    return this;\n  }\n\n  redraw(callback?) {\n    if (typeof callback === 'function') {\n      this._redrawCallbacks.push(callback);\n    }\n    if (this._frame === null) {\n      this._frame = Util.requestAnimFrame(this._redraw, this);\n    }\n    return this;\n  }\n\n  onAdd(map) {\n    this._map = map;\n    this.canvas = this.canvas || document.createElement('canvas');\n\n    const size = this._map.getSize()\n      , animated = this._map.options.zoomAnimation && Browser.any3d\n      ;\n\n    this.canvas.width = size.x;\n    this.canvas.height = size.y;\n\n    this.canvas.className = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');\n\n    map._panes.overlayPane.appendChild(this.canvas);\n\n    map.on('moveend', this._reset, this);\n    map.on('resize',  this._resize, this);\n\n    if (map.options.zoomAnimation && Browser.any3d) {\n      map.on('zoomanim', this._animateZoom, this);\n    }\n\n    this._reset();\n  }\n\n  onRemove(map) {\n    map.getPanes().overlayPane.removeChild(this.canvas);\n\n    map.off('moveend', this._reset, this);\n    map.off('resize', this._resize, this);\n\n    if (map.options.zoomAnimation) {\n      map.off('zoomanim', this._animateZoom, this);\n    }\n  }\n\n  addTo(map) {\n    map.addLayer(this);\n    return this;\n  }\n\n  _resize(resizeEvent) {\n    this.canvas.width  = resizeEvent.newSize.x;\n    this.canvas.height = resizeEvent.newSize.y;\n  }\n\n  _reset() {\n    const topLeft = this._map.containerPointToLayerPoint([0, 0]);\n    DomUtil.setPosition(this.canvas, topLeft);\n    this._redraw();\n  }\n\n  _redraw() {\n    const size    = this._map.getSize()\n      , bounds    = this._map.getBounds()\n      , zoomScale = (size.x * 180) / (20037508.34  * (bounds.getEast() - bounds.getWest())) // resolution = 1/zoomScale\n      , zoom      = this._map.getZoom()\n      ;\n\n    if (this._userDrawFunc) {\n      this._userDrawFunc(this, {\n        canvas   :this.canvas,\n        bounds   : bounds,\n        size     : size,\n        zoomScale: zoomScale,\n        zoom     : zoom,\n        options  : this.options\n      });\n    }\n\n    while (this._redrawCallbacks.length > 0) {\n      this._redrawCallbacks.shift()(this);\n    }\n\n    this._frame = null;\n  }\n\n  _animateZoom(e) {\n    // @ts-ignore\n    const scale = this._map.getZoomScale(e.zoom)\n        , offset = Layer\n          // @ts-ignore\n          ? this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), e.zoom, e.center).min\n          // @ts-ignore\n          : this._map._getCenterOffset(e.center)\n              ._multiplyBy(-scale)\n              // @ts-ignore\n              .subtract(this._map._getMapPanePos())\n      ;\n\n    DomUtil.setTransform(this.canvas, offset, scale);\n  }\n\n  setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[DomUtil.TRANSFORM] =\n      (Browser.ie3d ?\n        'translate(' + pos.x + 'px,' + pos.y + 'px)' :\n        'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\n      (scale ? ' scale(' + scale + ')' : '');\n  }\n}\n\nexport function canvasOverlay(userDrawFunc, options?) {\n  return new CanvasOverlay(userDrawFunc, options);\n}\n","export class MapMatrix {\n  array: Float32Array;\n  constructor() {\n    this.array = new Float32Array(16);\n  }\n  set(array: ArrayLike<number>, offset?: number): this {\n    this.array.set(array, offset);\n    return this;\n  }\n  translateMatrix(tx: number, ty: number) {\n    const { array } = this;\n    // translation is in last column of matrix\n    array[12] += array[0] * tx + array[4] * ty;\n    array[13] += array[1] * tx + array[5] * ty;\n    array[14] += array[2] * tx + array[6] * ty;\n    array[15] += array[3] * tx + array[7] * ty;\n\n    return this;\n  }\n  scaleMatrix(scale: number) {\n    const { array } = this;\n    // scaling x and y, which is just scaling first two columns of matrix\n    array[0] *= scale;\n    array[1] *= scale;\n    array[2] *= scale;\n    array[3] *= scale;\n\n    array[4] *= scale;\n    array[5] *= scale;\n    array[6] *= scale;\n    array[7] *= scale;\n\n    return this;\n  }\n}\n","import { Map } from 'leaflet';\nimport { FeatureCollection } from 'geojson';\n\nimport { CanvasOverlay } from './canvasoverlay';\nimport { MapMatrix } from './map-matrix';\nimport { IColor } from './color';\n\nexport interface IBaseSettings {\n  map: Map;\n  shaderVars: {\n    [name: string]: {\n      type: 'FLOAT';\n      start: number;\n      size: number;\n      bytes?: number;\n    }\n  }\n  data: any;\n  longitudeKey?: number;\n  latitudeKey?: number;\n  attachShaderVars?:\n    (byteCount: number,\n     gl: WebGLRenderingContext,\n     program: WebGLProgram,\n     attributes: object) => void;\n  setupClick?: (map: Map) => void;\n  vertexShaderSource?: (() => string) | string;\n  fragmentShaderSource?: (() => string) | string;\n  canvas: HTMLCanvasElement;\n  click?: (e, feature) => void;\n  color?: (featureIndex: number, feature) => void | IColor | string;\n  className?: string;\n  opacity?: number;\n  preserveDrawingBuffer?: boolean;\n}\n\nexport abstract class Base<T extends IBaseSettings = IBaseSettings> {\n  active: boolean;\n  fragmentShader: any;\n  canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext;\n  glLayer: CanvasOverlay;\n  mapMatrix: MapMatrix;\n  matrix: WebGLUniformLocation;\n  pixelsToWebGLMatrix: Float32Array;\n  program: WebGLProgram;\n  settings: T;\n  vertexShader: any;\n  verts: any;\n\n  abstract render();\n\n  constructor(settings: T) {\n    this.pixelsToWebGLMatrix = new Float32Array(16);\n    this.mapMatrix = new MapMatrix();\n    this.active = true;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.program = null;\n    this.matrix = null;\n    this.verts = null;\n    const preserveDrawingBuffer = Boolean(settings.preserveDrawingBuffer);\n    const glLayer = this.glLayer = new CanvasOverlay(() => {\n      this.drawOnCanvas();\n    })\n      .addTo(settings.map);\n    const canvas = this.canvas = glLayer.canvas;\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    canvas.style.position = 'absolute';\n    if (settings.className) {\n      canvas.className += ' ' + settings.className;\n    }\n    this.gl = (canvas.getContext('webgl', { preserveDrawingBuffer })\n      || canvas.getContext('experimental-webgl', { preserveDrawingBuffer })) as WebGLRenderingContext;\n  }\n\n  abstract drawOnCanvas(): this;\n\n  setData(data): this {\n    this.settings.data = data;\n    return this;\n  }\n\n  setup() {\n    const settings = this.settings;\n    if (settings.click) {\n      settings.setupClick(settings.map);\n    }\n\n    return this\n      .setupVertexShader()\n      .setupFragmentShader()\n      .setupProgram();\n  }\n\n  setupVertexShader() {\n    const gl = this.gl\n      , settings = this.settings\n      , vertexShaderSource = typeof settings.vertexShaderSource === 'function'\n          ? settings.vertexShaderSource()\n          : settings.vertexShaderSource\n      , vertexShader = gl.createShader(gl.VERTEX_SHADER)\n      ;\n\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.compileShader(vertexShader);\n\n    this.vertexShader = vertexShader;\n\n    return this;\n  }\n\n  setupFragmentShader() {\n    const gl = this.gl\n      , settings = this.settings\n      , fragmentShaderSource = typeof settings.fragmentShaderSource === 'function'\n          ? settings.fragmentShaderSource()\n          : settings.fragmentShaderSource\n      , fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n      ;\n\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    gl.compileShader(fragmentShader);\n\n    this.fragmentShader = fragmentShader;\n\n    return this;\n  }\n\n  setupProgram(): this {\n    // link shaders to create our program\n    const gl = this.gl\n      , program = gl.createProgram()\n      ;\n\n    gl.attachShader(program, this.vertexShader);\n    gl.attachShader(program, this.fragmentShader);\n    gl.linkProgram(program);\n    gl.useProgram(program);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n\n    this.program = program;\n\n    return this;\n  }\n\n  addTo(map) {\n    this.glLayer.addTo(map || this.settings.map);\n    this.active = true;\n    return this.render();\n  }\n\n  remove() {\n    this.settings.map.removeLayer(this.glLayer as any);\n    this.active = false;\n    return this;\n  }\n}","import { pointInCircle } from './utils';\nimport { latLng, LatLng } from './leaflet-bindings';\nimport { Base, IBaseSettings } from './base';\n\nexport interface IPointsSettings extends IBaseSettings {\n  closest: (targetLocation, points, map) => Points;\n  size: (i: number, latLng: typeof LatLng) => number;\n  eachVertex?: (dataLatLng, pixel, color) => void;\n}\n\nconst defaults: IPointsSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  closest: null,\n  attachShaderVars: null,\n  setupClick: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  eachVertex: null,\n  click: null,\n  color: 'random',\n  opacity: 0.8,\n  size: null,\n  className: '',\n  sensitivity: 2,\n  shaderVars: {\n    vertex: {\n      type: 'FLOAT',\n      start: 0,\n      size: 2,\n      bytes: 6\n    },\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 3,\n      bytes: 6\n    },\n    pointSize: {\n      type: 'FLOAT',\n      start: 5,\n      size: 1,\n      bytes: 6\n    },\n  }\n};\n\nexport class Points extends Base<IPointsSettings> {\n  static instances: Points[] = [];\n  static defaults = defaults;\n  static maps = [];\n  latLngLookup: { [key: string]: number[] };\n  verts: number[];\n\n  constructor(settings) {\n    super(settings);\n    Points.instances.push(this);\n    this.settings = {...Points.defaults, ...settings};\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n\n    this.active = true;\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n\n    this.resetVertices();\n\n    //look up the locations for the inputs to our shaders.\n    const gl = this.gl\n      , settings = this.settings\n      , canvas = this.canvas\n      , program = this.program\n      , glLayer = this.glLayer\n      , matrix = this.matrix = gl.getUniformLocation(program, 'matrix')\n      , opacity = gl.getUniformLocation(program, 'opacity')\n      , vertexBuffer = gl.createBuffer()\n      , vertexArray = new Float32Array(this.verts)\n      , byteCount = vertexArray.BYTES_PER_ELEMENT\n      ;\n\n    //set the matrix to some that makes 1 unit 1 pixel.\n    this.pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(matrix, false, this.pixelsToWebGLMatrix);\n    gl.uniform1f(opacity, this.settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);\n\n    if (settings.shaderVars !== null) {\n      this.settings.attachShaderVars(byteCount, gl, program, settings.shaderVars);\n    }\n\n    glLayer.redraw();\n\n    return this;\n  }\n\n  resetVertices() {\n    //empty verts and repopulate\n    this.latLngLookup = {};\n    this.verts = [];\n\n    // -- data\n    const verts = this.verts\n      , settings = this.settings\n      , data = settings.data\n      , max = data.length\n      , latLngLookup = this.latLngLookup\n      , latitudeKey = settings.latitudeKey\n      , longitudeKey = settings.longitudeKey\n      ;\n    let colorFn\n      , color = settings.color\n      , size = settings.size\n      , sizeFn\n      , dataLatLng\n      , pixel\n      , lookup\n      , key\n      , i = 0\n      ;\n\n    if (color === null) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n      color = undefined;\n    }\n\n    if (size === null) {\n      throw new Error('size is not properly defined');\n    } else if (typeof size === 'function') {\n      sizeFn = size;\n      size = undefined;\n    }\n\n    for (; i < max; i++) {\n      dataLatLng = data[i];\n      key = dataLatLng[latitudeKey].toFixed(2) + 'x' + dataLatLng[longitudeKey].toFixed(2);\n      lookup = latLngLookup[key];\n      pixel = settings.map.project(latLng(dataLatLng[latitudeKey], dataLatLng[longitudeKey]), 0);\n\n      if (lookup === undefined) {\n        lookup = latLngLookup[key] = [];\n      }\n\n      lookup.push(dataLatLng);\n\n      if (colorFn) {\n        color = colorFn(i, dataLatLng);\n      }\n\n      if (sizeFn) {\n        size = sizeFn(i, dataLatLng);\n      }\n\n      //-- 2 coord, 3 rgb colors, 1 size interleaved buffer\n      verts.push(pixel.x, pixel.y, color.r, color.g, color.b, size);\n      if (settings.eachVertex !== null) {\n        settings.eachVertex.call(this, dataLatLng, pixel, color);\n      }\n    }\n\n    return this;\n  }\n\n  pointSize(pointIndex) {\n    const settings = this.settings,\n      map = settings.map,\n      size = settings.size,\n      pointSize = typeof size === 'function' ? size(pointIndex, null) : size,\n      // -- Scale to current zoom\n      zoom = map.getZoom();\n\n    return pointSize === null ? Math.max(zoom - 4.0, 1.0) : pointSize;\n  }\n\n  drawOnCanvas(): this {\n    if (this.gl == null) return this;\n\n    const gl = this.gl,\n      canvas = this.canvas,\n      settings = this.settings,\n      map = settings.map,\n      bounds = map.getBounds(),\n      topLeft = new LatLng(bounds.getNorth(), bounds.getWest()),\n      offset = map.project(topLeft, 0),\n      zoom = map.getZoom(),\n      scale = Math.pow(2, zoom),\n      mapMatrix = this.mapMatrix,\n      pixelsToWebGLMatrix = this.pixelsToWebGLMatrix;\n\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n    //set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .set(pixelsToWebGLMatrix)\n      .scaleMatrix(scale)\n      .translateMatrix(-offset.x, -offset.y);\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n    gl.drawArrays(gl.POINTS, 0, settings.data.length);\n\n    return this;\n  }\n\n  lookup(coords): typeof LatLng {\n    const xMax = coords.lat + 0.03\n      , yMax = coords.lng + 0.03\n      , matches = []\n      ;\n    let x = coords.lat - 0.03\n      , y\n      , foundI\n      , foundMax\n      , found\n      , key\n      ;\n\n    for (; x <= xMax; x += 0.01) {\n      y = coords.lng - 0.03;\n      for (; y <= yMax; y += 0.01) {\n        key = x.toFixed(2) + 'x' + y.toFixed(2);\n        found = this.latLngLookup[key];\n        if (found) {\n          foundI = 0;\n          foundMax = found.length;\n          for (; foundI < foundMax; foundI++) {\n            matches.push(found[foundI]);\n          }\n        }\n      }\n    }\n\n    //try matches first, if it is empty, try the data, and hope it isn't too big\n    return this.settings.closest(coords, matches.length === 0 ? this.settings.data.slice(0) : matches, this.settings.map);\n  }\n\n  static tryClick(e, map) {\n    const closestFromEach = []\n      , instancesLookup = {}\n      ;\n    let result\n      , settings\n      , instance\n      , point\n      , xy\n      , found\n      , foundLatLng\n      ;\n\n    Points.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      point = _instance.lookup(e.latlng);\n      instancesLookup[point] = _instance;\n      closestFromEach.push(point);\n    });\n\n    if (closestFromEach.length < 1) return;\n    if (!settings) return;\n\n    found = settings.closest(e.latlng, closestFromEach, map);\n\n    if (found === null) return;\n\n    instance = instancesLookup[found];\n    if (!instance) return;\n\n    foundLatLng = latLng(found[settings.latitudeKey], found[settings.longitudeKey]);\n    xy = map.latLngToLayerPoint(foundLatLng);\n\n    const pointIndex = typeof instance.settings.size === 'function' ? instance.settings.data.indexOf(found) : null;\n    if (pointInCircle(xy, e.layerPoint, instance.pointSize(pointIndex) * instance.settings.sensitivity)) {\n      result = instance.settings.click(e, found, xy);\n      return result !== undefined ? result : true;\n    }\n  }\n}\n","import { Map } from 'leaflet';\nimport earcut from 'earcut';\n// import {FeatureCollection, GeoJsonObject} from 'geojson';\nimport PolygonLookup from 'polygon-lookup';\nimport geojsonFlatten from 'geojson-flatten';\n\nimport { LatLng, latLng } from './leaflet-bindings';\nimport { CanvasOverlay } from './canvasoverlay';\nimport { MapMatrix } from './map-matrix';\nimport { Base, IBaseSettings } from './base';\n\nexport interface IShapeSettings extends IBaseSettings {\n}\n\nconst defaults: IShapeSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  attachShaderVars: null,\n  setupClick: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  click: null,\n  color: 'random',\n  className: '',\n  opacity: 0.5,\n  shaderVars: {\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 3\n    }\n  }\n};\n\nexport class Shapes extends Base<IShapeSettings> {\n  static instances: Shapes[] = [];\n  static defaults = defaults;\n  static maps: Map[];\n\n  active: boolean;\n  settings: IShapeSettings;\n  glLayer: CanvasOverlay;\n  canvas: HTMLCanvasElement;\n  pixelsToWebGLMatrix: Float32Array;\n  mapMatrix: MapMatrix;\n  matrix: WebGLUniformLocation;\n  verts: number[];\n  polygonLookup: PolygonLookup;\n  aPointSize: number;\n\n  constructor(settings: IShapeSettings) {\n    super(settings);\n    Shapes.instances.push(this);\n    this.settings = { ...Shapes.defaults, ...settings };\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n    this.polygonLookup = null;\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n    // triangles or point count\n\n    const pixelsToWebGLMatrix = this.pixelsToWebGLMatrix\n      , settings = this.settings\n      , canvas = this.canvas\n      , gl = this.gl\n      , glLayer = this.glLayer\n      , verts = this.verts\n      , vertexBuffer = gl.createBuffer()\n      , vertArray = new Float32Array(verts)\n      , size = vertArray.BYTES_PER_ELEMENT\n      , program = this.program\n      , vertex = gl.getAttribLocation(program, 'vertex')\n      , opacity = gl.getUniformLocation(program, 'opacity')\n      ;\n    gl.uniform1f(opacity, this.settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, size * 5, 0);\n    gl.enableVertexAttribArray(vertex);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = gl.getUniformLocation(program, 'matrix');\n    this.aPointSize = gl.getAttribLocation(program, 'pointSize');\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.uniformMatrix4fv(this.matrix, false, pixelsToWebGLMatrix);\n\n    if (settings.shaderVars !== null) {\n      settings.attachShaderVars(size, gl, program, settings.shaderVars);\n    }\n\n    glLayer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.verts = [];\n    this.polygonLookup = new PolygonLookup();\n\n    const verts = this.verts\n      , polygonLookup = this.polygonLookup\n      , settings = this.settings\n      , data = settings.data as any\n      ;\n\n    let pixel\n      , index\n      , features\n      , feature\n      , color = settings.color\n      , colorFn\n      , coordinates\n      , featureIndex = 0\n      , featureMax\n      , triangles\n      , indices\n      , flat\n      , dim\n      ;\n\n    switch (data.type) {\n      case 'Feature':\n        polygonLookup.loadFeatureCollection({\n          type: 'FeatureCollection',\n          features: [data]\n        });\n        features = geojsonFlatten(data);\n        break;\n      case 'MultiPolygon':\n        polygonLookup.loadFeatureCollection({\n          type: 'FeatureCollection',\n          features: [{\n            type: 'Feature',\n            properties: { id: 'bar' },\n            geometry: { coordinates: data.coordinates }\n          }]\n        });\n        features = geojsonFlatten(data);\n        break;\n      default:\n        polygonLookup.loadFeatureCollection(data);\n        features = data.features;\n    }\n    console.log(features, polygonLookup);\n    featureMax = features.length;\n\n    if (color === null) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n      color = undefined;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      triangles = [];\n\n      //use colorFn function here if it exists\n      if (colorFn) {\n        color = colorFn(featureIndex, feature);\n      }\n\n      coordinates = (feature.geometry || feature).coordinates;\n      flat = earcut.flatten(coordinates);\n      indices = earcut(flat.vertices, flat.holes, flat.dimensions);\n      console.log(flat, indices);\n      dim = coordinates[0][0].length;\n      for (let i = 0, iMax = indices.length; i < iMax; i++) {\n        index = indices[i];\n        if (typeof flat.vertices[0] === 'number') {\n          triangles.push(flat.vertices[index * dim + settings.longitudeKey], flat.vertices[index * dim + settings.latitudeKey]);\n        } else {\n          throw new Error('unhandled polygon');\n        }\n      }\n\n      for (let i = 0, iMax = triangles.length; i < iMax; i) {\n        pixel = settings.map.project(latLng(triangles[i++], triangles[i++]), 0);\n        verts.push(pixel.x, pixel.y, color.r, color.g, color.b);\n      }\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(): this {\n    if (!this.gl) return this;\n\n    const settings = this.settings\n      , canvas = this.canvas\n      , map = settings.map\n      , pointSize = Math.max(map.getZoom() - 4.0, 1.0)\n      , bounds = map.getBounds()\n      , topLeft = new LatLng(bounds.getNorth(), bounds.getWest())\n      // -- Scale to current zoom\n      , scale = Math.pow(2, map.getZoom())\n      , offset = map.project(topLeft, 0)\n      , mapMatrix = this.mapMatrix\n      , pixelsToWebGLMatrix = this.pixelsToWebGLMatrix\n      ;\n\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n    // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n    mapMatrix\n      .set(pixelsToWebGLMatrix)\n      .scaleMatrix(scale)\n      .translateMatrix(-offset.x, -offset.y);\n\n    const gl = this.gl;\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.vertexAttrib1f(this.aPointSize, pointSize);\n    // -- attach matrix value to 'mapMatrix' uniform in shader\n    gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n    gl.drawArrays(gl.TRIANGLES, 0, this.verts.length / 5);\n\n    return this;\n  }\n\n  static tryClick(e, map): boolean {\n    let result\n      , settings\n      , feature\n      ;\n\n    Shapes.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      feature = _instance.polygonLookup.search(e.latlng.lng, e.latlng.lat);\n      if (feature !== undefined) {\n        result = settings.click(e, feature);\n      }\n    });\n\n    return result !== undefined ? result : true;\n  }\n}\n","import { Map, LatLng } from 'leaflet';\nimport { latLng } from './leaflet-bindings';\nimport { IPixel } from './pixel';\n\ninterface ILineFeatureVerticesSettings {\n  project: (coordinates: LatLng, distance: number) => IPixel;\n  color: any;\n  latitudeKey?: number;\n  longitudeKey?: number;\n}\n\nexport class LineFeatureVertices {\n  project: (coordinates: LatLng, distance: number) => IPixel;\n  latitudeKey?: number;\n  longitudeKey?: number;\n  color: any;\n  vertexCount: number;\n  array: number[];\n  length: number;\n\n  constructor(settings: ILineFeatureVerticesSettings) {\n    Object.assign(this, settings);\n    this.vertexCount = 0;\n    this.array = [];\n    this.length = 0;\n  }\n\n  fillFromCoordinates(coordinates) {\n    const { color } = this;\n    for (let i = 0; i < coordinates.length; i++) {\n      if (Array.isArray(coordinates[i][0])) {\n        this.fillFromCoordinates(coordinates[i]);\n        continue;\n      }\n      const pixel = this.project(\n        latLng(\n          coordinates[i][this.latitudeKey],\n          coordinates[i][this.longitudeKey]\n        ), 0);\n      this.push(pixel.x, pixel.y, color.r, color.g, color.b);\n      if (i !== 0 && i !== coordinates.length - 1) {\n        this.vertexCount += 1;\n      }\n      this.vertexCount += 1;\n    }\n  }\n\n  push(...args) {\n    this.array.push(...args);\n    this.length = this.array.length;\n  }\n}","import { latLng, LatLng } from './leaflet-bindings';\nimport { Base, IBaseSettings } from './base';\nimport { LineFeatureVertices } from './line-feature-vertices';\n\nexport interface ILinesSettings extends IBaseSettings {\n  weight: ((i: number, feature: any) => number) | number;\n}\n\nconst defaults: ILinesSettings = {\n  map: null,\n  data: [],\n  longitudeKey: null,\n  latitudeKey: null,\n  attachShaderVars: null,\n  setupClick: null,\n  vertexShaderSource: null,\n  fragmentShaderSource: null,\n  click: null,\n  color: 'random',\n  className: '',\n  opacity: 0.5,\n  weight: 2,\n  shaderVars: {\n    color: {\n      type: 'FLOAT',\n      start: 2,\n      size: 3\n    }\n  }\n};\n\nexport class Lines extends Base<ILinesSettings> {\n  static defaults = defaults;\n  static instances: Lines[] = [];\n\n  allVertices: number[];\n  verts: LineFeatureVertices[];\n  aPointSize: number;\n\n  constructor(settings: ILinesSettings) {\n    super(settings);\n    Lines.instances.push(this);\n    this.settings = { ...Lines.defaults, ...settings };\n\n    if (!settings.data) throw new Error('no \"data\" array setting defined');\n    if (!settings.map) throw new Error('no leaflet \"map\" object setting defined');\n\n    this.active = true;\n    this.allVertices = [];\n\n    this\n      .setup()\n      .render();\n  }\n\n  render(): this {\n    this.resetVertices();\n\n    const pixelsToWebGLMatrix = this.pixelsToWebGLMatrix\n      , settings = this.settings\n      , canvas = this.canvas\n      , gl = this.gl\n      , glLayer = this.glLayer\n      , verts = this.verts\n      , vertexBuffer = gl.createBuffer()\n      , program = this.program\n      , vertex = gl.getAttribLocation(program, 'vertex')\n      , opacity = gl.getUniformLocation(program, 'opacity')\n      ;\n\n    gl.uniform1f(opacity, this.settings.opacity);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    /*\n    Transforming lines according to the rule:\n    1. Take one line (single feature)\n    [[0,0],[1,1],[2,2]]\n    2. Split the line in segments, duplicating all coordinates except first and last one\n    [[0,0],[1,1],[2,2]] => [[0,0],[1,1],[1,1],[2,2]]\n    3. Do this for all lines and put all coordinates in array\n    */\n    let size = verts.length;\n    const allVertices = [];\n    for (let i = 0; i < size; i++) {\n      const vertices = verts[i].array;\n      const length = vertices.length / 5;\n      for (let j = 0; j < length; j++) {\n        const vertexIndex = j * 5;\n        if (j !== 0 && j !== (length - 1)) {\n          allVertices.push(\n            vertices[vertexIndex],\n            vertices[vertexIndex + 1],\n            vertices[vertexIndex + 2],\n            vertices[vertexIndex + 3],\n            vertices[vertexIndex + 4]\n          );\n        }\n        allVertices.push(\n          vertices[vertexIndex],\n          vertices[vertexIndex + 1],\n          vertices[vertexIndex + 2],\n          vertices[vertexIndex + 3],\n          vertices[vertexIndex + 4]\n        );\n      }\n    }\n\n    this.allVertices = allVertices;\n\n    const vertArray = new Float32Array(allVertices);\n    size = vertArray.BYTES_PER_ELEMENT;\n    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, size * 5, 0);\n    gl.enableVertexAttribArray(vertex);\n\n    //  gl.disable(gl.DEPTH_TEST);\n    // ----------------------------\n    // look up the locations for the inputs to our shaders.\n    this.matrix = gl.getUniformLocation(program, 'matrix');\n    this.aPointSize = gl.getAttribLocation(program, 'pointSize');\n\n    // Set the matrix to some that makes 1 unit 1 pixel.\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    gl.uniformMatrix4fv(this.matrix, false, pixelsToWebGLMatrix);\n\n    if (settings.shaderVars !== null) {\n      settings.attachShaderVars(size, gl, program, settings.shaderVars);\n    }\n\n    glLayer.redraw();\n\n    return this;\n  }\n\n  resetVertices(): this {\n    this.allVertices = [];\n    this.verts = [];\n\n    const verts = this.verts\n      , settings = this.settings\n      , data = settings.data\n      , features = data.features\n      , map = settings.map\n      , latitudeKey = settings.latitudeKey\n      , longitudeKey = settings.longitudeKey\n      , featureMax = features.length\n      ;\n\n    let feature\n      , color = settings.color\n      , colorFn\n      , featureIndex = 0\n      ;\n\n    if (color === null) {\n      throw new Error('color is not properly defined');\n    } else if (typeof color === 'function') {\n      colorFn = color;\n      color = undefined;\n    }\n\n    // -- data\n    for (; featureIndex < featureMax; featureIndex++) {\n      feature = features[featureIndex];\n      //use colorFn function here if it exists\n      if (colorFn) {\n        color = colorFn(featureIndex, feature);\n      }\n      const featureVertices = new LineFeatureVertices({\n        project: map.project.bind(map),\n        latitudeKey,\n        longitudeKey,\n        color,\n      });\n      featureVertices.fillFromCoordinates(feature.geometry.coordinates);\n      verts.push(featureVertices);\n    }\n\n    return this;\n  }\n\n  drawOnCanvas(): this {\n    if (this.gl == null) return this;\n\n    const gl = this.gl\n      , settings = this.settings\n      , canvas = this.canvas\n      , map = settings.map\n      , weight = settings.weight\n      , zoom = map.getZoom()\n      , pointSize = Math.max(zoom - 4.0, 4.0)\n      , bounds = map.getBounds()\n      , topLeft = new LatLng(bounds.getNorth(), bounds.getWest())\n        // -- Scale to current zoom\n      , scale = Math.pow(2, zoom)\n      , offset = map.project(topLeft, 0)\n      , mapMatrix = this.mapMatrix\n      , pixelsToWebGLMatrix = this.pixelsToWebGLMatrix\n      ;\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    pixelsToWebGLMatrix.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.vertexAttrib1f(this.aPointSize, pointSize);\n    if (zoom > 18) {\n      mapMatrix\n        .set(pixelsToWebGLMatrix)\n        .scaleMatrix(scale)\n        .translateMatrix(-offset.x, -offset.y);\n      // -- attach matrix value to 'mapMatrix' uniform in shader\n      gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n      gl.drawArrays(gl.LINES, 0, this.allVertices.length / 5);\n    } else if (typeof weight === 'number') {\n      // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n      for (let yOffset = -weight; yOffset < weight; yOffset += 0.5) {\n        for (let xOffset = -weight; xOffset < weight; xOffset += 0.5) {\n          // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n          mapMatrix\n            .set(pixelsToWebGLMatrix)\n            .scaleMatrix(scale)\n            .translateMatrix(-offset.x + (xOffset / scale), -offset.y + (yOffset / scale));\n          // -- attach matrix value to 'mapMatrix' uniform in shader\n          gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n          gl.drawArrays(gl.LINES, 0, this.allVertices.length / 5);\n        }\n      }\n    } else if (typeof weight === 'function') {\n      let allVertexCount = 0;\n      const features = this.settings.data.features;\n      const { verts } = this;\n      for (let i = 0; i < verts.length; i++) {\n        const featureVertices = verts[i];\n        const vertexCount = featureVertices.vertexCount;\n        const weightValue = weight(i, features[i]);\n        // Now draw the lines several times, but like a brush, taking advantage of the half pixel line generally used by cards\n        for (let yOffset = -weightValue; yOffset < weightValue; yOffset += 0.5) {\n          for (let xOffset = -weightValue; xOffset < weightValue; xOffset += 0.5) {\n            // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\n            mapMatrix\n              .set(pixelsToWebGLMatrix)\n              .scaleMatrix(scale)\n              .translateMatrix(-offset.x + (xOffset / scale), -offset.y + (yOffset / scale));\n            // -- attach matrix value to 'mapMatrix' uniform in shader\n            gl.uniformMatrix4fv(this.matrix, false, mapMatrix.array);\n\n            gl.drawArrays(gl.LINES, allVertexCount, vertexCount);\n          }\n        }\n        allVertexCount += vertexCount;\n      }\n    }\n    return this;\n  }\n\n  static tryClick(e, map): void {\n    let foundFeature = false\n      , instance = null\n      , record = 0.1\n      , settings\n      ;\n    Lines.instances.forEach(function (_instance) {\n      settings = _instance.settings;\n      if (!_instance.active) return;\n      if (settings.map !== map) return;\n      if (!settings.click) return;\n\n      settings.data.features.map(feature => {\n        for (let i = 1; i < feature.geometry.coordinates.length; i++) {\n          let distance = pDistance(e.latlng.lng, e.latlng.lat,\n            feature.geometry.coordinates[i - 1][0], feature.geometry.coordinates[i - 1][1],\n            feature.geometry.coordinates[i][0], feature.geometry.coordinates[i][1]);\n          if (distance < record) {\n            record = distance;\n            foundFeature = feature;\n            instance = _instance;\n          }\n        }\n      });\n    });\n\n    if (instance) {\n      instance.settings.click(e, foundFeature);\n    } else {\n      return;\n    }\n  }\n}\n\nfunction pDistance(x, y, x1, y1, x2, y2): number {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const len_sq = C * C + D * D;\n  let param = -1;\n  if (len_sq !== 0) //in case of 0 length line\n    param = dot / len_sq;\n\n  let xx, yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  let dx = x - xx;\n  let dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n","export interface IColor {\n  r: number;\n  g: number;\n  b: number;\n}\n\nconst green: IColor = {r: 0, g: 1, b: 0};\nconst red: IColor = {r: 1, g: 0, b: 0};\nconst blue: IColor = {r: 0, g: 0, b: 1};\nconst teal: IColor = {r: 0, g: 1, b: 1};\nconst yellow: IColor = {r: 1, g: 1, b: 0};\n\nconst white: IColor = {r: 1, g: 1, b: 1};\nconst black: IColor = {r: 0, g: 0, b: 0};\n\nconst gray: IColor = {r: 0.5, g: 0.5, b: 0.5};\n\nexport class Color {\n  static green;\n  static red;\n  static blue;\n  static teal;\n  static yellow;\n  static white;\n  static black;\n  static gray;\n  static get grey() {\n    return gray;\n  }\n\n  static fromHex(hex): IColor | null {\n    if (hex.length < 6) return null;\n    hex = hex.toLowerCase();\n\n    if (hex[0] === '#') {\n      hex = hex.substring(1, hex.length);\n    }\n\n    const r = parseInt(hex[0] + hex[1], 16)\n      , g = parseInt(hex[2] + hex[3], 16)\n      , b = parseInt(hex[4] + hex[5], 16)\n      ;\n    return { r: r / 255, g: g / 255, b: b / 255 };\n  }\n\n  random(): IColor {\n    return {\n      r: Math.random(),\n      g: Math.random(),\n      b: Math.random()\n    };\n  }\n\n  pallet(): IColor {\n    switch (Math.round(Math.random() * 4)) {\n      case 0:\n        return green;\n      case 1:\n        return red;\n      case 2:\n        return blue;\n      case 3:\n        return teal;\n      case 4:\n        return yellow;\n    }\n  }\n}","import { Map } from 'leaflet';\nimport { Points, IPointsSettings } from './points';\nimport { IShapeSettings, Shapes} from './shapes';\nimport { Lines, ILinesSettings } from './lines';\nimport { MapMatrix } from './map-matrix';\nimport { Color } from './color';\n\n// @ts-ignore\nimport vertex from './shader/vertex/default.glsl';\n// @ts-ignore\nimport dot from './shader/fragment/dot.glsl';\n// @ts-ignore\nimport point from './shader/fragment/point.glsl';\n// @ts-ignore\nimport puck from './shader/fragment/puck.glsl';\n// @ts-ignore\nimport simpleCircle from './shader/fragment/simple-circle.glsl';\n// @ts-ignore\nimport square from './shader/fragment/square.glsl';\n// @ts-ignore\nimport polygon from './shader/fragment/polygon.glsl';\n\nconst shader = {\n  vertex,\n  fragment: {\n    dot,\n    point,\n    puck,\n    simpleCircle,\n    square,\n    polygon,\n  }\n};\n\nclass Glify {\n  color: Color = new Color();\n  longitudeKey: number = 1;\n  latitudeKey: number = 0;\n  maps: Map[] = [];\n  shader = shader;\n\n  Points: typeof Points = Points;\n  Shapes: typeof Shapes = Shapes;\n  Lines: typeof Lines = Lines;\n  mapMatrix: MapMatrix;\n\n  longitudeFirst(): this {\n    this.longitudeKey = 0;\n    this.latitudeKey = 1;\n    return this;\n  }\n\n  latitudeFirst(): this {\n    this.latitudeKey = 0;\n    this.longitudeKey = 1;\n    return this;\n  }\n\n  get instances() {\n    return [\n      ...Points.instances,\n      ...Shapes.instances,\n      ...Lines.instances\n    ];\n  }\n\n  points(settings: IPointsSettings): Points {\n    return new Points({\n      setupClick: glify.setupClick.bind(this),\n      attachShaderVars: glify.attachShaderVars.bind(this),\n      latitudeKey: glify.latitudeKey,\n      longitudeKey: glify.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.point;\n      },\n      color: this.color.random,\n      closest: this.closest.bind(this),\n      ...settings,\n    });\n  }\n\n  shapes(settings: IShapeSettings): Shapes {\n    return new Shapes({\n      setupClick: this.setupClick.bind(this),\n      attachShaderVars: this.attachShaderVars.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      color: this.color.random,\n      ...settings\n    });\n  }\n\n  lines(settings: ILinesSettings): Lines {\n    return new Lines({\n      setupClick: this.setupClick.bind(this),\n      attachShaderVars: this.attachShaderVars.bind(this),\n      latitudeKey: this.latitudeKey,\n      longitudeKey: this.longitudeKey,\n      vertexShaderSource: () => {\n        return this.shader.vertex;\n      },\n      fragmentShaderSource: () => {\n        return this.shader.fragment.polygon;\n      },\n      color: this.color.random,\n      ...settings\n    });\n  }\n\n  setupClick(map?: Map): void {\n    if (this.maps.indexOf(map) < 0) {\n      this.maps.push(map);\n      map.on('click', function (e) {\n        let hit;\n        hit = Points.tryClick(e, map);\n        if (hit !== undefined) return hit;\n\n        hit = Lines.tryClick(e, map);\n        if (hit !== undefined) return hit;\n\n        hit = Shapes.tryClick(e, map);\n        if (hit !== undefined) return hit;\n      });\n    }\n  }\n\n  pointInCircle(centerPoint, checkPoint, radius): boolean {\n    const distanceSquared = (centerPoint.x - checkPoint.x) * (centerPoint.x - checkPoint.x) + (centerPoint.y - checkPoint.y) * (centerPoint.y - checkPoint.y);\n    return distanceSquared <= radius * radius;\n  }\n\n  attachShaderVars(byteCount, gl, program, attributes): this {\n    const bytes = 5;\n\n    for (const name in attributes) if (attributes.hasOwnProperty(name)) {\n      const attribute = attributes[name];\n      const loc = gl.getAttribLocation(program, name);\n      if (loc < 0) {\n        console.log(name, attribute);\n        throw new Error('shader variable ' + name + ' not found');\n      }\n      gl.vertexAttribPointer(\n        loc,\n        attribute.size,\n        gl[attribute.type],\n        !!attribute.normalize,\n        byteCount * (attribute.bytes || bytes),\n        byteCount * attribute.start);\n      gl.enableVertexAttribArray(loc);\n    }\n\n    return this;\n  }\n\n  debugPoint(containerPoint): this {\n    const el = document.createElement('div')\n      , s = el.style\n      , x = containerPoint.x\n      , y = containerPoint.y\n      ;\n\n    s.left = x + 'px';\n    s.top = y + 'px';\n    s.width = '10px';\n    s.height = '10px';\n    s.position = 'absolute';\n    s.backgroundColor = '#' + (Math.random() * 0xFFFFFF << 0).toString(16);\n\n    document.body.appendChild(el);\n\n    return this;\n  }\n\n  closest(targetLocation, points, map): Points {\n    if (points.length < 1) return null;\n    return points.reduce((prev, curr) => {\n      const prevDistance = this.locationDistance(targetLocation, prev, map)\n        , currDistance = this.locationDistance(targetLocation, curr, map)\n        ;\n      return (prevDistance < currDistance) ? prev : curr;\n    });\n  }\n\n  vectorDistance(dx, dy): number {\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  locationDistance(location1, location2, map): number {\n    const point1 = map.latLngToLayerPoint(location1)\n      , point2 = map.latLngToLayerPoint(location2)\n      , dx = point1.x - point2.x\n      , dy = point1.y - point2.y\n      ;\n    return this.vectorDistance(dx, dy);\n  }\n}\n\nconst glify = new Glify();\nexport default module.exports = glify;\nif (typeof window !== 'undefined' && window.L) {\n  // @ts-ignore\n  window['L'].glify = glify;\n  // @ts-ignore\n  window['L'].Glify = Glify;\n}"]}